[ToC]

# Start

![Redis总结](http://img.zhengyua.cn/img/20201111080318.jpg)

# Redis

## 持久化策略

![Redis持久化策略](http://img.zhengyua.cn/img/20201111092408.png)

## 缓存策略

**Cache-Aside**

- **应用程序会在命中数据源之前先检查缓存**

![](http://img.zhengyua.cn/img/20191201143233.png)

适用于**读多的场景**。

> 此策略并不能保证数据存储和缓存的一致性问题。

**Read-Through**

- 应用程序无需管理数据源与缓存，只需要将数据源的同步委托给缓存提供程序`Cache-Provider`即可

即所有的数据交互都是**通过抽象缓存层**完成的。

![](http://img.zhengyua.cn/img/20191201144633.png)

适用于**比较稳定的读多**场景。

> 在大量读取的情况下可以减少对数据源上的负载，也对缓存服务的故障具备一定的弹性。
>
> 相当于在`Cache-Aside`进行封装，配置不同的缓存服务。

**Write-Through**

- 当发生数据更新下通过缓存提供程序来负责**更新底层数据源和缓存**，缓存与数据源保持一致，且写入时始终通过抽象缓存层到达数据层。

![](http://img.zhengyua.cn/img/20191201145812.png)

解决了**数据一致性**问题，但是数据**写入速度会降低**。

**Write-Behind**

- 引入队列，将**缓存的更新请求入队**,并且定期将其flush刷新到数据存储中,即在数据更新的时候直接写入缓存。

![](http://img.zhengyua.cn/img/20191201151004.png)

适用**写多**的场景，与`Read-Through`配合比较适合用在混合工作负载。

## 缓存故障

### 缓存雪崩

- 在同一时间大面积失效的缓存下,高并发的请求下直接将数据库打爆。

> 若是打爆一个的分库，而其他依赖它的库也会同时报错,如果没有做熔断等策略那基本上就全完了。

**解决方案**：

- 在Redis存数据的时候，把**每个Key的失效时间都加个随机值**即可；

- 若是对于**热点数据**，那就直接设置热点数据**永远不过期**，在更新时直接更新缓存就好了。

> 上面单机情况下的解决办法，但是Redis若是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题。

### 缓存穿透

- 请求在缓存和数据源中都没有或者不合理的数据。

没有做**参数校验**，比如故意请求一些不合理或者没有考虑到的数据，主键id负值或者整数最大值等等不容易考虑到的键值。

**解决方案**：

- 增加参数校验，不合法的参数直接返回；
- 将该不合法的值也加入缓存，并设置合理的过期时间；
- 使用布隆过滤器（Bloom Filter）。

> 布隆过滤器利用高效的数据结构和算法快速判断出key是否存在。

### 缓存击穿

- 一个接受着高并发的Key突然失效，导致并发请求穿过缓存，直接请求数据库。

**解决方案**：

- 通过Zookper或Redis加上**互斥锁**；

  > 在缓存失效的时候下不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。

- **提前**使用互斥锁；

  在value内部设置超时值，发现其过期时延长超时值然后再从数据库加载数据并设置到cache中。

- 设置热点数据**永不过期**；

  可通过静态设置的永不过期，也可以设置一个异步线程检测是否过期，若要过期则重新设置缓存。

- 利用hystrix做资源的隔离保护主线程池，进行资源保护。

## memcached 

### MySQL+Memcached架构

Memcached采用**客户端-服务器**的架构，客户端和服务器端的通讯使用自定义的协议标准，只要满足协议格式要求，客户端Library可以用任何语言实现。 

Memcached服务器使用**基于Slab的内存管理方式**，有利于减少内存碎片和频繁分配销毁内存所带来的开销。

各个Slab按需动态**分配一个page的内存**（和4Kpage的概念不同，这里默认page为1M），page 内部按照不同slab class的尺寸**再划分为内存chunk供服务器存储KV键值对使用**（slab机制相当于内存池机制, 实现从操作系统分配一大块内存, 然后 memcached 自 己管理这块内存, 负责分配与回收。）

### memcached的内存分配机制

实际MySQL是适合进行海量数据存储的，通过Memcached将**热点数据加载到cache**，加速访问。

- MySQL需要不断进行拆库拆表，Memcached也需要跟着不断扩容，扩容和维护工作占据大量开发时间；
- Memcached与MySQL数据库存在数据一致性问题；
- Memcached数据命中率低或down机，穿透到DB使MySQL无法支撑；
- 跨机房cache同步问题。

### memcached问题

总体上这些NoSQL主要用于解决 以下几种问题：

- 少量数据存储，**高速读写访问**。（in-memory方式保持高速访问，同时提供数据落地的功能）
- 海量数据存储，**分布式系统支持**，**数据一致性保证**，方便的集群节点添加/删除。

- 这方面最具代表性的是dynamo和bigtable2篇论文所阐述的思路。前者是一个**完全无中心的设 计**，节点之间通过gossip方式传递集群信息，数据保证最终一致性，后者是一个**中心化的方案设计**，通 过类似一个分布式锁服务来保证强一致性,数据**写入先写内存和redo log**，然后**定期compat归并到磁盘 上**，将随机写优化为**顺序写**，提高写入性能。

- **Schema free，auto-sharding**等。

  > 比如目前常见的一些文档数据库都是支持schema-free的，直接存储json格式数据，并且支持auto-sharding等功能，比如mongodb。

### Redis与memcached比较

- Redis支持丰富的数据结构；
- Redis支持数据的备份，即master-slave模式的数据备份；
- Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载使用；

## 数据类型

![image-20201111132212126](http://img.zhengyua.cn/img/20201111132212.png)

> type：数据类型；
>
> encoding：编码格式（存储方式）；

### 数据结构

![image-20201111132326836](http://img.zhengyua.cn/img/20201111132326.png)

**简单动态字符串**：

![image-20201111132624335](http://img.zhengyua.cn/img/20201111132624.png)

> - 字符串长度处理；
> - 内存重新分配：空间预分配，惰性空间释放；
> - 二进制安全；

**双端链表**：

![image-20201111133120873](http://img.zhengyua.cn/img/20201111133121.png)

> - 前后节点|头尾节点
> - 链表长度

**压缩列表**：

![](http://img.zhengyua.cn/img/20201111133206.png)

> - 压缩列表的内存是连续分配；
> - 为了提升内存使用效率设计，经过特殊编码，其操作都是通过指针与解码出来的偏移量进行的；

**字典**：

- key-value；
- 哈希表；

**跳跃表**：

![image-20201111133406136](http://img.zhengyua.cn/img/20201111133406.png)

![image-20201111133434287](http://img.zhengyua.cn/img/20201111133434.png)

- O(logN) ；

### string

- key-value；
- **常见命令**：`set`，`get`，`decr`，`incr`，`mget`等；
- **数据编码**：存储数字的话，采用**int类型**的编码，如果是非数字的话，采用 **raw 编码**；

**应用场景**：String是最常用的一种数据类型，其key-value类型归为此类，即实现memcached功能。

- **缓存功能**；
- **计数器**；
- **共享用户Session**；

### hash

- **常用命令**：`hget`，`hset`，`hgetall`等；
- **数据编码**：当成员较少时使用**zipmap**，当成员数量增大时使用**ht**；

**应用场景**：类似于利用**存储序列化结构信息**，若使用memcached或者string类型实现当结构信息更新时会增大开销，也不适用于一些可能并发操作的场合。hash类型**可只修改某一项值**。但是不能处理**嵌套的结构化数据**。

![image-20201111133751962](http://img.zhengyua.cn/img/20201111133752.png)



> 需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。

### List

- **常用命令**：`lpush`，`rpush`，`lpop`，`rpop`，`lrange`等；
- **数据编码**：字符串长度及元素个数小于一定范围使用 **ziplist 编码**，任意条件不满足，则转化为 **linkedlist 编码**；

**应用场景**：

- 信息列表|根据时间排序的列表信息；
- **消息队列**；
- **文章列表或者数据分页展示的应用**；

> 常见的如关注列表、最新发布信息等；

### Set

- **常用命令**：`sadd`，`spop`，`smembers`，`sunion`等

- **数据编码**：保存元素为整数及元素个数小于一定范围使用 **intset 编码**，任意条件不满足，则使用 **hashtable 编码**；

**应用场景**：

- 自动排重列表信息；
- 判断列表是否有重复信息；
- 集合操作（交集|并集|差集等）；

> 常见的如共同关注好友等；

### Sorted Set

- **常用命令**：`zadd`，`zrange`，`zrem`，`zcard`等；

- **数据编码**：保存的元素个数小于及成员长度小于一定值使用 **ziplist 编码**，任意条件不满足，则使用 **skiplist 编码**；

**应用场景**：

- 根据score排序的列表信息；
- 权重队列；
- 自动排重列表信息；

### Pub/Sub

- 发布与订阅；

> 常用做实时消息系统，如普通的即时聊天、群聊等功能；

### Transcations

- 提供不严格的ACID事务；
- 提供基本的命令打包执行功能，保证执行顺序；
- 提供Watch功能检测Key，判断是否执行Transcations；

## 应用场景

Redis在很多方面与其他数据库解决方案不同：它使用**内存提供主存储支持**，而**仅使用硬盘做持久性的存储**；它的数据模型非常独特，用的是单线程。另一个大区别在于，你可以在开发环境中使用Redis的功能，但却不需要转到Redis。

在一些需要大容量数据集的应用，Redis也并不适合，因为它的**数据集不会超过系统可用的内存**。所以如果你有大数据应用，而且主要是**读取访问模式**，那么Redis并不是正确的选择。

常见的应用场景如下：

- 显示最新的项目列表；
- 删除与过滤；
- 排行榜相关；
- 按照用户投票和时间排序；
- 处理过期项目；
- 计数；
- 特定时间内的特定项目；
- 用户数据统计与防止垃圾邮件等的实时分析；
- Pub/Sub；
- 队列；
- 缓存。

## 线程模型

![image-20201111141759763](http://img.zhengyua.cn/img/20201111141759.png)

**I/O多路复用模型**：

- I/O：网络I/O；
- 多路：多个TCP连接；
- 复用：共用一个线程或进程；

应对大量的请求，Redis 中使用 I/O 多路复用程序同时监听多个套接字，并将这些事件推送到一个队列里，然后逐个被执行。最终将结果返回给客户端。

**避免上下文切换**：

- **多线程在执行过程中需要进行 CPU 的上下文切换**，这个操作比较耗时。Redis 又是基于内存实现的，对于内存来说，**没有上下文切换效率就是最高的**。多次读写都在一个CPU 上，对于内存来说就是最佳方案。

**单线程模型**：

使用了 **Reactor 单线程模型**。

![image-20201111142038359](http://img.zhengyua.cn/img/20201111142038.png)

### 并发带来的数据问题

比如在操作相同Key进行的流程顺序改变。

![](http://img.zhengyua.cn/img/20201111142648.png)

- 解决方法：**基于Zookeeper实现分布式锁**，或者通过MySQL查出的缓存数据记录了相应标识如时间戳，则可以判断是否为新数据还是旧数据；

### 双存储双写出现的数据一致性问题

一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统不是严格要 求 **“缓存+数据库” 必须保持一致性**的话，最好不要做这个方案，即：**读请求和写请求串行化**，串到一个 **内存队列**里去,但这非常影响系统的效率,且很容易成为整个**系统的弱点和瓶颈**。



